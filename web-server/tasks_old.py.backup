"""
任务管理器
负责任务队列、执行和状态管理
"""

import json
import logging
import threading
import time
import uuid
import base64
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
from queue import Queue

# 添加 mac-server 目录到路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'mac-server'))

from config import TASK_HISTORY_FILE, MAX_TASK_HISTORY
from phone_controller_remote import PhoneControllerRemote

logger = logging.getLogger(__name__)


class TaskStatus:
    """任务状态枚举"""
    PENDING = 'pending'      # 等待执行
    RUNNING = 'running'      # 执行中
    COMPLETED = 'completed'  # 已完成
    FAILED = 'failed'        # 失败


class Task:
    """任务对象"""

    def __init__(self, description: str, task_id: str = None):
        self.id = task_id or str(uuid.uuid4())
        self.description = description
        self.status = TaskStatus.PENDING
        self.created_at = datetime.now().isoformat()
        self.started_at: Optional[str] = None
        self.completed_at: Optional[str] = None
        self.logs: List[str] = []
        self.screenshot: Optional[str] = None  # Base64 编码的截图
        self.error: Optional[str] = None

    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            'id': self.id,
            'description': self.description,
            'status': self.status,
            'created_at': self.created_at,
            'started_at': self.started_at,
            'completed_at': self.completed_at,
            'logs': self.logs,
            'screenshot': self.screenshot,
            'error': self.error,
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Task':
        """从字典创建任务"""
        task = cls(data['description'], data['id'])
        task.status = data['status']
        task.created_at = data['created_at']
        task.started_at = data.get('started_at')
        task.completed_at = data.get('completed_at')
        task.logs = data.get('logs', [])
        task.screenshot = data.get('screenshot')
        task.error = data.get('error')
        return task

    def add_log(self, message: str):
        """添加日志"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        log_entry = f"[{timestamp}] {message}"
        self.logs.append(log_entry)
        logger.info(f"任务 {self.id[:8]}: {message}")


class TaskManager:
    """
    任务管理器（单例）
    管理任务队列、执行和历史记录
    """

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if hasattr(self, '_initialized'):
            return

        self._initialized = True
        self.current_task: Optional[Task] = None
        self.task_queue = Queue()
        self.task_history: Dict[str, Task] = {}
        self.worker_thread: Optional[threading.Thread] = None
        self.running = False

        # 初始化手机控制器
        try:
            self.phone_controller = PhoneControllerRemote()
            logger.info("✅ 手机控制器初始化成功")
        except Exception as e:
            logger.error(f"❌ 手机控制器初始化失败: {e}")
            self.phone_controller = None

        # 加载历史记录
        self._load_history()

    def submit_task(self, description: str) -> Task:
        """
        提交新任务
        """
        task = Task(description)
        task.add_log("任务已提交到队列")

        # 添加到队列
        self.task_queue.put(task)

        # 添加到历史
        self.task_history[task.id] = task

        # 启动 worker（如果未启动）
        if not self.running:
            self.start_worker()

        logger.info(f"任务已提交: {task.id}, 描述: {description}")
        return task

    def get_task(self, task_id: str) -> Optional[Task]:
        """获取任务"""
        return self.task_history.get(task_id)

    def get_current_task(self) -> Optional[Task]:
        """获取当前正在执行的任务"""
        return self.current_task

    def get_recent_tasks(self, limit: int = 20) -> List[Task]:
        """获取最近的任务列表"""
        tasks = sorted(
            self.task_history.values(),
            key=lambda t: t.created_at,
            reverse=True
        )
        return tasks[:limit]

    def start_worker(self):
        """启动任务执行线程"""
        if self.running:
            logger.warning("Worker 已在运行")
            return

        self.running = True
        self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
        self.worker_thread.start()
        logger.info("任务 worker 已启动")

    def stop_worker(self):
        """停止任务执行线程"""
        self.running = False
        if self.worker_thread:
            self.worker_thread.join(timeout=5)
        logger.info("任务 worker 已停止")

    def _worker_loop(self):
        """
        Worker 主循环
        从队列中取任务并执行
        """
        logger.info("Worker 循环已启动")

        while self.running:
            try:
                # 从队列获取任务（超时 1 秒）
                if not self.task_queue.empty():
                    task = self.task_queue.get(timeout=1)
                    self.current_task = task

                    # 执行任务
                    self._execute_task(task)

                    self.current_task = None
                    self.task_queue.task_done()
                else:
                    time.sleep(0.5)

            except Exception as e:
                logger.error(f"Worker 循环错误: {e}", exc_info=True)
                time.sleep(1)

        logger.info("Worker 循环已退出")

    def _execute_task(self, task: Task):
        """
        执行单个任务
        """
        try:
            task.status = TaskStatus.RUNNING
            task.started_at = datetime.now().isoformat()
            task.add_log("开始执行任务...")

            # 检查手机控制器是否可用
            if not self.phone_controller:
                raise Exception("手机控制器未初始化")

            # 执行真实的任务
            self._execute_real_task(task)

            # 完成
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now().isoformat()
            task.add_log("✅ 任务执行完成")

        except Exception as e:
            task.status = TaskStatus.FAILED
            task.completed_at = datetime.now().isoformat()
            task.error = str(e)
            task.add_log(f"❌ 任务执行失败: {e}")
            logger.error(f"任务 {task.id} 执行失败: {e}", exc_info=True)

        finally:
            # 保存历史
            self._save_history()

    def _execute_real_task(self, task: Task):
        """
        执行真实任务
        支持的命令格式：
        - "截图" - 截取手机屏幕
        - "点击 x,y" - 点击指定坐标
        - "滑动 x1,y1,x2,y2" - 滑动手势
        - "输入 文本" - 输入文字
        - 其他文本 - 简单测试（截图+点击中心）
        """
        description = task.description.strip()

        # 解析命令
        if description == "截图" or description.startswith("screenshot"):
            task.add_log("正在截取屏幕...")
            self._do_screenshot(task)

        elif description.startswith("点击"):
            # 格式: "点击 100,200" 或 "点击 100 200"
            parts = description.replace(",", " ").split()
            if len(parts) >= 3:
                try:
                    x = int(parts[1])
                    y = int(parts[2])
                    task.add_log(f"正在点击坐标 ({x}, {y})...")
                    self._do_tap(task, x, y)
                except ValueError:
                    raise Exception(f"无效的坐标格式: {description}")
            else:
                raise Exception("点击命令格式错误，应为: 点击 x,y")

        elif description.startswith("滑动"):
            # 格式: "滑动 100,200,300,400"
            parts = description.replace(",", " ").split()
            if len(parts) >= 5:
                try:
                    x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4])
                    task.add_log(f"正在滑动 ({x1},{y1}) -> ({x2},{y2})...")
                    self._do_swipe(task, x1, y1, x2, y2)
                except ValueError:
                    raise Exception(f"无效的坐标格式: {description}")
            else:
                raise Exception("滑动命令格式错误，应为: 滑动 x1,y1,x2,y2")

        elif description.startswith("输入"):
            # 格式: "输入 你好世界"
            text = description[2:].strip()
            if text:
                task.add_log(f"正在输入文字: {text}")
                self._do_input(task, text)
            else:
                raise Exception("输入命令格式错误，应为: 输入 文本内容")

        else:
            # 默认：演示性任务（截图 + 简单测试）
            task.add_log(f"执行任务: {description}")
            task.add_log("正在截取屏幕...")
            self._do_screenshot(task)
            time.sleep(1)
            task.add_log("测试点击屏幕中心...")
            self._do_tap(task, 540, 1000)  # 大部分手机的中心位置

    def _do_screenshot(self, task: Task):
        """截取屏幕并保存到任务"""
        try:
            image = self.phone_controller.screenshot()
            if image:
                # 转换为 Base64
                from io import BytesIO
                buffer = BytesIO()
                image.save(buffer, format='PNG')
                img_data = base64.b64encode(buffer.getvalue()).decode()
                task.screenshot = f"data:image/png;base64,{img_data}"
                task.add_log(f"✅ 截图成功 ({image.size[0]}x{image.size[1]})")
            else:
                task.add_log("⚠️ 截图失败")
        except Exception as e:
            task.add_log(f"⚠️ 截图错误: {e}")

    def _do_tap(self, task: Task, x: int, y: int):
        """执行点击"""
        try:
            success = self.phone_controller.tap(x, y)
            if success:
                task.add_log(f"✅ 点击成功 ({x}, {y})")
            else:
                task.add_log(f"⚠️ 点击失败")
        except Exception as e:
            task.add_log(f"⚠️ 点击错误: {e}")

    def _do_swipe(self, task: Task, x1: int, y1: int, x2: int, y2: int, duration: int = 300):
        """执行滑动"""
        try:
            success = self.phone_controller.swipe(x1, y1, x2, y2, duration)
            if success:
                task.add_log(f"✅ 滑动成功")
            else:
                task.add_log(f"⚠️ 滑动失败")
        except Exception as e:
            task.add_log(f"⚠️ 滑动错误: {e}")

    def _do_input(self, task: Task, text: str):
        """输入文字"""
        try:
            success = self.phone_controller.input_text(text)
            if success:
                task.add_log(f"✅ 输入成功")
            else:
                task.add_log(f"⚠️ 输入失败")
        except Exception as e:
            task.add_log(f"⚠️ 输入错误: {e}")

        task.add_log("正在截取屏幕...")
        time.sleep(1)
        # 模拟截图（实际应调用 phone_controller.get_screenshot()）
        task.screenshot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="

        task.add_log("正在分析屏幕内容...")
        time.sleep(1)

        task.add_log(f"正在执行操作: {task.description}")
        time.sleep(2)

        task.add_log("正在验证结果...")
        time.sleep(1)

    def _load_history(self):
        """从文件加载任务历史"""
        if not TASK_HISTORY_FILE.exists():
            logger.info("任务历史文件不存在，创建新文件")
            return

        try:
            with open(TASK_HISTORY_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                for task_dict in data:
                    task = Task.from_dict(task_dict)
                    self.task_history[task.id] = task
            logger.info(f"已加载 {len(self.task_history)} 条任务历史")
        except Exception as e:
            logger.error(f"加载任务历史失败: {e}", exc_info=True)

    def _save_history(self):
        """保存任务历史到文件"""
        try:
            # 只保留最近的记录
            recent_tasks = self.get_recent_tasks(MAX_TASK_HISTORY)
            data = [task.to_dict() for task in recent_tasks]

            # 确保目录存在
            TASK_HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)

            # 写入文件
            with open(TASK_HISTORY_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            logger.debug(f"任务历史已保存: {len(data)} 条记录")
        except Exception as e:
            logger.error(f"保存任务历史失败: {e}", exc_info=True)


# 全局单例
task_manager = TaskManager()
