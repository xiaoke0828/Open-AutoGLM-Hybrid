"""
任务管理器
负责任务队列、执行和状态管理
"""

import json
import logging
import threading
import time
import uuid
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
from queue import Queue

from config import TASK_HISTORY_FILE, MAX_TASK_HISTORY

logger = logging.getLogger(__name__)


class TaskStatus:
    """任务状态枚举"""
    PENDING = 'pending'      # 等待执行
    RUNNING = 'running'      # 执行中
    COMPLETED = 'completed'  # 已完成
    FAILED = 'failed'        # 失败


class Task:
    """任务对象"""

    def __init__(self, description: str, task_id: str = None):
        self.id = task_id or str(uuid.uuid4())
        self.description = description
        self.status = TaskStatus.PENDING
        self.created_at = datetime.now().isoformat()
        self.started_at: Optional[str] = None
        self.completed_at: Optional[str] = None
        self.logs: List[str] = []
        self.screenshot: Optional[str] = None  # Base64 编码的截图
        self.error: Optional[str] = None

    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            'id': self.id,
            'description': self.description,
            'status': self.status,
            'created_at': self.created_at,
            'started_at': self.started_at,
            'completed_at': self.completed_at,
            'logs': self.logs,
            'screenshot': self.screenshot,
            'error': self.error,
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Task':
        """从字典创建任务"""
        task = cls(data['description'], data['id'])
        task.status = data['status']
        task.created_at = data['created_at']
        task.started_at = data.get('started_at')
        task.completed_at = data.get('completed_at')
        task.logs = data.get('logs', [])
        task.screenshot = data.get('screenshot')
        task.error = data.get('error')
        return task

    def add_log(self, message: str):
        """添加日志"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        log_entry = f"[{timestamp}] {message}"
        self.logs.append(log_entry)
        logger.info(f"任务 {self.id[:8]}: {message}")


class TaskManager:
    """
    任务管理器（单例）
    管理任务队列、执行和历史记录
    """

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if hasattr(self, '_initialized'):
            return

        self._initialized = True
        self.current_task: Optional[Task] = None
        self.task_queue = Queue()
        self.task_history: Dict[str, Task] = {}
        self.worker_thread: Optional[threading.Thread] = None
        self.running = False

        # 加载历史记录
        self._load_history()

    def submit_task(self, description: str) -> Task:
        """
        提交新任务
        """
        task = Task(description)
        task.add_log("任务已提交到队列")

        # 添加到队列
        self.task_queue.put(task)

        # 添加到历史
        self.task_history[task.id] = task

        # 启动 worker（如果未启动）
        if not self.running:
            self.start_worker()

        logger.info(f"任务已提交: {task.id}, 描述: {description}")
        return task

    def get_task(self, task_id: str) -> Optional[Task]:
        """获取任务"""
        return self.task_history.get(task_id)

    def get_current_task(self) -> Optional[Task]:
        """获取当前正在执行的任务"""
        return self.current_task

    def get_recent_tasks(self, limit: int = 20) -> List[Task]:
        """获取最近的任务列表"""
        tasks = sorted(
            self.task_history.values(),
            key=lambda t: t.created_at,
            reverse=True
        )
        return tasks[:limit]

    def start_worker(self):
        """启动任务执行线程"""
        if self.running:
            logger.warning("Worker 已在运行")
            return

        self.running = True
        self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
        self.worker_thread.start()
        logger.info("任务 worker 已启动")

    def stop_worker(self):
        """停止任务执行线程"""
        self.running = False
        if self.worker_thread:
            self.worker_thread.join(timeout=5)
        logger.info("任务 worker 已停止")

    def _worker_loop(self):
        """
        Worker 主循环
        从队列中取任务并执行
        """
        logger.info("Worker 循环已启动")

        while self.running:
            try:
                # 从队列获取任务（超时 1 秒）
                if not self.task_queue.empty():
                    task = self.task_queue.get(timeout=1)
                    self.current_task = task

                    # 执行任务
                    self._execute_task(task)

                    self.current_task = None
                    self.task_queue.task_done()
                else:
                    time.sleep(0.5)

            except Exception as e:
                logger.error(f"Worker 循环错误: {e}", exc_info=True)
                time.sleep(1)

        logger.info("Worker 循环已退出")

    def _execute_task(self, task: Task):
        """
        执行单个任务
        """
        try:
            task.status = TaskStatus.RUNNING
            task.started_at = datetime.now().isoformat()
            task.add_log("开始执行任务...")

            # TODO: 这里集成 Open-AutoGLM
            # 当前为模拟实现，实际应调用 phone_controller_remote.py

            # 模拟执行步骤
            self._simulate_task_execution(task)

            # 完成
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now().isoformat()
            task.add_log("✅ 任务执行完成")

        except Exception as e:
            task.status = TaskStatus.FAILED
            task.completed_at = datetime.now().isoformat()
            task.error = str(e)
            task.add_log(f"❌ 任务执行失败: {e}")
            logger.error(f"任务 {task.id} 执行失败: {e}", exc_info=True)

        finally:
            # 保存历史
            self._save_history()

    def _simulate_task_execution(self, task: Task):
        """
        模拟任务执行（用于测试）
        实际使用时应替换为真实的 Open-AutoGLM 调用
        """
        import time

        task.add_log("正在连接手机...")
        time.sleep(1)

        task.add_log("正在截取屏幕...")
        time.sleep(1)
        # 模拟截图（实际应调用 phone_controller.get_screenshot()）
        task.screenshot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="

        task.add_log("正在分析屏幕内容...")
        time.sleep(1)

        task.add_log(f"正在执行操作: {task.description}")
        time.sleep(2)

        task.add_log("正在验证结果...")
        time.sleep(1)

    def _load_history(self):
        """从文件加载任务历史"""
        if not TASK_HISTORY_FILE.exists():
            logger.info("任务历史文件不存在，创建新文件")
            return

        try:
            with open(TASK_HISTORY_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                for task_dict in data:
                    task = Task.from_dict(task_dict)
                    self.task_history[task.id] = task
            logger.info(f"已加载 {len(self.task_history)} 条任务历史")
        except Exception as e:
            logger.error(f"加载任务历史失败: {e}", exc_info=True)

    def _save_history(self):
        """保存任务历史到文件"""
        try:
            # 只保留最近的记录
            recent_tasks = self.get_recent_tasks(MAX_TASK_HISTORY)
            data = [task.to_dict() for task in recent_tasks]

            # 确保目录存在
            TASK_HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)

            # 写入文件
            with open(TASK_HISTORY_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            logger.debug(f"任务历史已保存: {len(data)} 条记录")
        except Exception as e:
            logger.error(f"保存任务历史失败: {e}", exc_info=True)


# 全局单例
task_manager = TaskManager()
